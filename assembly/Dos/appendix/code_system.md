# 码制

## 原码

如果真值是正数，则最高位是 0，其它位保持不变；  
如果真值是负数，则最高位是 1，其它位保持不变；

例如： 写出 13 和 -13 的原码（取 8 位码长）  
13：  0000 1101
-13： 1000 1101

## 反码

如果真值是正数，则最高位是 0，其它位保持不变；  
如果真值是负数，则最高位是 1，其它位取反；

例如： 写出 13 和 -13 的反码（取 8 位码长）  
13：  0000 1101
-13： 1111 0010

## 补码

如果真值是正数，则最高位是 0，其它位保持不变；   
如果真值是负数，则最高位是 1，其它位取反后加一；  
需要特别指出： 如果取 8 位码长，0000 0000 特指 0；  
计算时，溢出的部分删除；  

例如： 写出 13 和 -13 的补码（取 8 位码长）  
13：  0000 1101
-13： 1111 0011

补码的存在，是为了计算时候的统一，本质上是正负 0 的统一。  
比如说 -0: 1000 0000, 用补码表示为 0000 0000  

## 移码

缘由： 用补码表示阶码的时候，当阶码无限小，产生了下溢的时候，阶码变成了0，那么这个浮点数的值变为了1。
而实际上这个数是无限接近于零的。

移码（又叫增码或偏置码）通常用于表示浮点数的阶码  

如果取 8 位码长，存储的元数据是 +127，具体示例由单精度浮点数（Float）来解释


### 单精度浮点数（Float）

符合 IEEE R32.24 标准，32 是指 32 位，24 是指精度 24 bit

1. 符号位(Sign)：0代表正，1代表为负，占用 1 bit；
2. 指数位(Exponent)：用于存储科学计数法中的指数数据，并且采用移位存储，占用 8 bit；
3. 尾数部分(Mantissa)：尾数部分，占用 23 bit，整数部分是 1，所以精度为 24 bit；

#### 示例 8.25D 在计算机中的存储

1000.01  
1.00001*2^3  

127 + 3 = 130  

0 1000 0010 0000 1000 0000 0000 0000 000



### 浮点数浅析

双精度浮点数符合 IEEE R64.53 标准，其它依照单精度浮点数类推

浮点数的位数都是有限的，在表示无限循环的实数的时候，肯定是有误差的。  

那么在一些情况下，加减乘除的运算中，肯定也是有误差的；

那么在一些情况下，在单双精度的相互转换中，肯定也是有误差的；




